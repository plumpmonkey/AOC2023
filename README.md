# AoC2023
Advent of Code 2023 Challenges

| Day    | Title                   | Description                                                     |
|:-------|:------------------------|:----------------------------------------------------------------|
| [Day 1](https://adventofcode.com/2023/day/1)  | Trebuchet?!        | More difficult than traditional Day 1 - Used `regex` to find digits in a string. Part 2 complex in that also used words, but text could overlap. Used `regex` instead of `re` for `overlapped` keyword |
| [Day 2](https://adventofcode.com/2023/day/2)  | Cube Conundrum     | Parsed input data into `Games` and `Rounds` using `split` and `enumerate`. Each round had coloured cubes. Some basic math on the results.  |
| [Day 3](https://adventofcode.com/2023/day/3)  | Gear Ratios     | Map the data into a 2D grid and examine adjacent data. Created `Point` and `Grid` classes to support this.  |
| [Day 4](https://adventofcode.com/2023/day/4)  | Scratchcards     | Created a `Scratchcard` class to store the card number, winning numbers and scratched numbers. Used a `set` to store the winning numbers and scratched numbers, so that we could easily find the intersection of the two sets to find the number of matches.  |
| [Day 5](https://adventofcode.com/2023/day/5)  | If You Give A Seed A Fertilizer     | Data is split into a seed list, and another list of lists containing the maps. For each seed we check if its in the range of the map, if it is we convert it to the new value and repeat until we get to the location map. Part 2 tricky |
| [Day 6](https://adventofcode.com/2023/day/6)  | Wait For It     | Fairly straight forward. Work through a list and calculate times. Could have used quadratic equation, when for an optimised brute force. Still runs < 1 second|
| [Day 7](https://adventofcode.com/2023/day/7) | Camel Cards | Used `Counter` to count the number of cards in a hand. Created a `Hand` class to store the hand and its rank. The `Hand` class has a `__lt__` method that compares Hand type of the hand, followed the rank of the card scores of two hands. |
| [Day 8](https://adventofcode.com/2023/day/8) | Haunted Wasteland | used `itertools.cycle` to create an infinite list of instructions. Used a dict to store the nodes and their left and right nodes. Used a `while` loop to follow the instructions until the `ZZZ` node was found. **Part 2** was not bruteforce-able, so determined that we need the **least common multiplier** of all the loop counts|
| [Day 9](https://adventofcode.com/2023/day/9) | Mirage Maintenance | Used `numpy` to perform a difference in values in a list. Recursive function to keep doing this until we get the right answers|
| [Day 10](https://adventofcode.com/2023/day/10) | Pipe Maze | A horrible day. Needed to extend the `Grid` class to cater for the pipes, and then use a BFS. Part 2 was a lot of guesswork on the code and still not quite sure why it works.  |
| [Day 11](https://adventofcode.com/2023/day/11) | Cosmic Expansion | Part 1 - The data was loaded using the `Grid` class, and used `itertools.combinations` to generate all pairs of galaxys. Used `Manhatten Distance` calculation to work out the distance between the pairs. Part 2 massively expanded the universe so wasnt bruteforceable. Changed the code to just add the values to the `Point` values and recompute manhattan distance  | 
| [Day 12](https://adventofcode.com/2023/day/12) | Hot Springs | Horrible recursive issue. Used `functools.lru_cache` to cache the results of the function. Part 2 was a simple change to unfold the inputs. As part 1 used a cache function, this is very quick to run.  |
| [Day 13](https://adventofcode.com/2023/day/13) | Point of Incidence | used `numpy` to find symmetry in the data by comparing rows. This would give us our reflection line. We can then work outwards finding how many rows are identical, and how many lines are remaining. Part 2 was a simple change to check for the number of differences between the two rows/columns. Used `np.sum` to count the number of differences and ensure we never go over 1 |
| [Day 14](https://adventofcode.com/2023/day/14) | Parabolic Reflector Dish | Parse the data into a `np.ndarray`. To shuffle the rocks we store the a dictionary of columns with the next available row we can insert into. As we hit a `O` or `#` this is updated. Itterate through each row and if we hit an `O` we can move it to the next available position. To calculate the final load, for each row, count the number of 'O' characters and multiply by the `number of rows in the platform - the current row`. For Part 2 - calculate when the pattern repeats and skip those cycles. Perform any remaining cycles and calculate the load (Similar problem to Tetris in 2022) |
| [Day 15](https://adventofcode.com/2023/day/15) | Lens Library | A simple exercise today. Create a method to perform the required hash operation on the input string and then sum the results. A much more indepth part 2. Created a `Box` class to store the `box number`, the list of `(lens, focal_length)` and a set of `lens` so we can quickly tell if a lens is in the box without having to loop through the list each time. With that in place, it was simple to follow the rules for adding, removing or updating the lenses in the boxes. |
| [Day16](https://adventofcode.com/2023/day/16) | The Floor Will Be Lava | Extended the `Grid` class. Implemented a `BFS` algorithm to to find the path, but added a lot of logic to the `get neighbours` function to handle the direction changes with the mirrors. The `visited` set was extended to not only include the `Point` but also the `Direction` the beam was travelling in. This is due to the same point could be visited multiple times, but with different directions. Part 2 - A minor modification to generate all the starting points and directions and just call the BFS lots of times. Takes about 10 seconds to run. |
| [Day17](https://adventofcode.com/2023/day/17) | Clumsy Crucible | Implemented a Dijkstra search algorithm to find the shortest path from the start to the end. Have to take into account the direction we are moving in to find the correct neighbour, and also track how many times we have travelled in a straight line. Once we hit a max of 3, we have to turn. Part 2 - Parameterised the min_steps before turning and maximum number of steps in a straight line. |